!> Module defining abstract class for first order solver.
module abstract_solver_first_order
    use, intrinsic :: iso_fortran_env
    implicit none
    private
    public :: t_abstract_solver_first_order

    !> Abstract class for first order solver 
    type, abstract :: t_abstract_solver_first_order
        private
        !> Solution at current time step
        real(real64), allocatable :: solution(:)

        !> True if initialize is called
        logical :: is_initialized = .false.

        !> True if set_initial_condition is called
        logical :: has_initial_condition = .false.

        !> True if set_initial_condition is called
        logical :: has_boundary_condition = .false.

        procedure(evaluate_flux_interface), deferred :: flux => null() 

        contains

        procedure(apply_boundary_condition_interface), deferred :: apply_boundary_condition
        procedure(evaluate_next_interface), deferred :: evaluate_next
    end type


    !> Interface for evaluate_next method
    abstract interface
        !> Evaluates the flux at i+1/2 th point
        function evaluate_flux_interface(this) result(f)
            import :: t_abstract_lae_1d_solver, real64
            class(t_abstract_lae_1d_solver), intent(inout) :: this
            !> Flux at at i+1/2 th point
            real(real64) :: f
        end function

        !> Apply boundary condition
        subroutine apply_boundary_condition_interface(q)
            import :: t_abstract_lae_1d_solver, real64
            class(t_abstract_lae_1d_solver), intent(inout) :: this
        end function

        !> Evaluates the solutin at next time step
        function evaluate_next_interface(this) result(h)
            import :: t_abstract_lae_1d_solver, real64
            class(t_abstract_lae_1d_solver), intent(inout) :: this
            !> Solution at next time step
            real(real64), allocatable :: h(:)
        end function
    end interface
end module
